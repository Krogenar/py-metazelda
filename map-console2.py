#from module import Module
#import settings
import datetime
import random
import networkx as nx
#from networkx.readwrite import json_graph
import re
import copy

"""
    1/31/18 TO DO LIST
    1. Move carving functions over to MapGenerator
    2. Create a basic testing suite
    3. Finish room intensity.
    4. Function to find suitable placement of Goal and Boss objects.
    5. Functions for placing Goal, Boss and updating key_levels for selected nodes.
    6. Function to place keys.
    7. Function to place Mob objects
    8. Function to place Traps
    9. Function to place Loot
    10. Function to create cycles in Map, placing new key_level restrictions (doors)
    11. random_dig algorithm
    12. cellular_automata_dig algorithm
    13. prim_dig algorithm

    Create the entrance room -- pick a random node.
    get_random_uncarved_node -- DONE
    place_object(node_name, "entrance") -- DONE
    get_node_data -- DONE, returns dictionary
    get_node_data / display_node_data -- DONE

    -Create a tree of linked rooms (including locked doors)
    -Creating the initial tree of rooms

    -The spanning tree of the eventual dungeon graph is generated by repeating the following steps until there are no
    -spaces left for rooms according to the constraints placed on the generator. While this is going on, the algorithm
    -tracks the current key-level, which is initially 0.

    -Choose a random room that has already been placed with an edge bordering an empty space. This is the parent room.
    -Randomly choose which adjacent empty space to extend into.
    -Create the new child room in this empty space, and link it to the parent room.
    -The parent property of the child room references the parent room, and the child list of the parent room is updated
    -to include the child room.
    - At regular intervals, the current key-level is incremented, and the edge to the parent room is made conditional
    - based on the symbol for the new current key-level.
    - The precondition for the child room is the current key-level.
    - The child room is added to the key-level room mapping for the current key-level.

    Place the boss and goal rooms
    Place the switch and switch-locks
    Make the tree into a graph -- make some interconnections, add a cycle where possible.
    Compute the intensity (difficulty) of rooms

    Place keys within the dungeon
    Optimizing linearity
"""

# Console printing.
# Found here: https://stackoverflow.com/questions/27265322/how-to-print-to-console-in-color
# print(R+"hello how are you"+W)
w = '\033[0m'     # white (normal)
R = '\033[1;31m'  # red
G = '\033[1;32m'  # green
Y = '\033[1;33m'  # yellow
B = '\033[1;34m'  # bright blue
P = '\033[1;35m'  # bright purple
C = '\033[1;36m'  # bright cyan

KL_COLORS = {0: w, 1: G, 2: Y, 3: B, 4: P, 5: C, 6: R}

class MapGenerator(object):
    """
    Intended as the VC (Viewer, Controller) object for Map objects.
    Functions will include:
    1. Viewing (various modes to show key levels, objects, mobs as needed)
    2. Moving within the Map object
    3. Digging within the Map object (including random Digging)
    4. Resetting an existing Map object.
    5. Analysis of Map objects for linearity and other features.
    6. Allow for creation of multiple Maps and selection of best.
    7. Allow for creation of new random carve algorithms and their application to a map.
    """
    NAME = 'MapGenerator'

    def __init__(self, name=None, description="A MapVC object.", view_radius=5):
        self.data = dict()
        self.data["id"] = self.get_random_hash()
        self.data["name"] = name
        self.data["description"] = description
        self.data["class"] = self.__class__.__name__  # For brain export/import.
        self.data["view_radius"] = int(view_radius)

    def get_random_hash(self):
        """Get a randomized hash. Provided by Guillaume Vander Est."""
        return "%010x" % random.getrandbits(10 * 4)

    # ANALYSIS

    def get_carved_edges_subgraph(self, map):
        """
        This returns a subgraph of the specific map consisting only of the nodes and edges that have
        been carved. This could also be used to 'trim out' excess nodes, edges after modification is over.
        :param map: The specified map.
        :return: subgraph of map
        """
        g = map.data["graph"]
        g_carved_edges = [(_[0], _[1]) for _ in map.get_edge_data() if _[2]["carved"] is True]
        return nx.edge_subgraph(g, g_carved_edges)

    def get_shortest_path(self, map, node1, node2):
        """
        This returns a list of the nodes that connect node1 to node2
        :param map: the map to be checked
        :param node1: the starting node, in the form 'row:col:lev:q'
        :param node2: as above. but the ending node
        :return: a list of nodes starting with node1, leading to node2
        """
        return nx.shortest_path(self.get_carved_edges_subgraph(map), node1, node2)

    # VIEWS

    def view(self,  map, **kwargs):
        """ This will show the basic Map object data. """
        if map.__class__.__name__ == 'Map':

            display_lst = self.get_graph_display(map, **kwargs)

            display_str = "\n".join(display_lst)
            print(display_str)

    def set_view_radius(self, radius):
        radius = int(radius)
        if radius >= 4:
            self.data["view_radius"] = radius
        else:
            self.data["view_radius"] = 4

    def get_display_constraints(self, map):
        """
        This will examine the map object against the view radius, set to 4
        :return: row_start, row_end, col_start, col_end in tuple
        """
        view_radius = radius = self.data["view_radius"]
        cur_row = map.data["cur_row"]
        cur_col = map.data["cur_col"]
        diameter = (view_radius * 2) + 1
        max_row = map.data["dim_y"]
        max_col = map.data["dim_x"]

        if max_row < diameter:
            row_start, row_end = 0, max_row
        else:
            row_start, row_end = cur_row - radius, cur_row + radius + 1
            if row_start < 0:
                row_start = 0

            if row_start > cur_row + radius:
                row_start = max_row

            if row_end < diameter:
                row_end = diameter

            if row_end > max_row:  # correct.
                row_end = max_row
                row_start = max_row - diameter

        if max_col < diameter:
            col_start, col_end = 0, max_col
        else:
            col_start, col_end = cur_col - radius, cur_col + radius + 1
            if col_start < 0:
                col_start = 0

            if col_start > cur_col + radius:
                col_start = max_col

            if col_end < diameter:
                col_end = diameter

            if col_end > max_col:  # correct.
                col_end = max_col
                col_start = max_col - diameter

        return row_start, row_end, col_start, col_end

    def get_graph_display(self, map, key_levels=False):
        """
        1/9/2018 -- added edge condition checking.
        COLOR CONDITIONS TO CHECK
        row                 column                  location                        os/rs/us = over,row,under
        0 < r < dim_y - 1   0 < c < dim_x -1        non-edge, non-corner node       pass
        ( in order in which they will be encountered )
        0                   0                       upper-left corner               os color
        0                   0 < c < dim_x - 1       top edge                        pass, color code should be in place already  ***
        0                   dim_x - 1               upper-right corner              os escape
        0 < r < dim_y - 1   0                       left edge                       rs color, rs escape
        0 < r < dim_y - 1   dim_x - 1               right edge                      rs color, rs escape
        dim_y - 1           0                       lower-left corner               us color
        dim_y - 1           0 < c < dim_x - 1       bottom edge                     pass, color code should be in place already   ***
        dim_y - 1           dim_x - 1               lower-right corner              us escape
        """

        report_lst = []  # This will hold the compiled row_strings.
        edges = map.get_edge_data()  # This gets all edge data for the entire graph.
        # edge_restr is a dict of dicts of all edges that have an edge restriction (key_level) and a direction
        # of east, south, or down -- which is all the function requires to draw the map.
        edge_restr = {_[0]: {"direction": _[2]["direction"], "key_level": _[2]["key_level"]} for _ in edges if _[2]["key_level"] is not None and ((_[2]["direction"] == 'east') or (_[2]["direction"] == 'south') or (_[2]["direction"] == 'down'))}
        door_data = []

        row_start, row_end, col_start, col_end = self.get_display_constraints(map)

        for r in xrange(row_start, row_end):
            row_string = ""  # Not defaulting to "|" because view could be truncated.

            # check color conditions for rows
            if r == 0:  # Could be upper left or upper right corner. Check in column loop.
                over_string = B + "+"
            else:
                over_string = "+"

            if r == map.data["dim_y"] - 1:  # treat as bottom left corner, when in column loop, check if bottom right.
                under_string = B + "+"
            else:
                under_string = "+"

            for c in xrange(col_start, col_end):

                # get basic node data
                node_name = map.node_code(r, c, map.data["cur_lev"], map.data["cur_q"])
                node_carved = map.data["graph"].node[node_name]["carved"]
                node_exits = map.get_carved_outward_edges_by_direction(node_name)
                node_entrances = map.get_carved_inward_edges_by_direction(node_name)

                # if topmost row, then build an over_string, subsequent rows will use under_string only.
                if r == row_start:  # The first row in the display, so determine top row.
                    if "north" in node_exits:
                        if "south" in node_entrances:
                            over_string += "   +"
                        else:
                            over_string += " ^ +"
                    else:
                        if "south" in node_entrances:
                            over_string += " v +"
                        else:
                            over_string += "---+"

                # determine of we're on a left edge, and if so, handle row_string color
                if (c == 0) and (0 < r < map.data["dim_y"] - 1):
                    over_string = B + over_string[:1] + w + over_string[1:]
                    row_string += B
                    under_string = B + under_string + w
                elif (c == 0) and (r == map.data["dim_y"] - 1):
                    row_string += B
                    under_string = B + under_string
                elif (c == 0) and (r == 0):
                    row_string += B
                    under_string = B + under_string + w

                # if we're in the first display column.
                if (c == col_start) and ("west" in node_exits):
                    if "west" in door_data:
                        row_string += G + "|" + w
                    else:
                        row_string += "|"

                elif (c == col_start) and ("west" not in node_exits):
                    row_string += "|"

                # escape color code, if needed.
                if c == 0:
                    row_string += w

                # Left edge of node done, now start node content.

                if r == map.data["cur_row"] and c == map.data["cur_col"]:
                    row_string += R + " O" + w + " "
                elif node_carved:  # blank node
                    if key_levels:  # show key_level for carved cells.
                        key_level = map.get_node_key_level(node_name)
                        klc = KL_COLORS.get(key_level, w)
                        if 10 > key_level >= 0:
                            row_string += " {}{}{} ".format(klc, int(key_level), w)
                        else:
                            row_string += " % "
                    else:
                        if "up" in node_exits and "down" in node_exits:
                            row_string += " X "
                        elif "up" in node_exits and "down" not in node_exits:
                            row_string += " ^ "
                        elif "up" not in node_exits and "down" in node_exits:
                            row_string += " v "
                        else:
                            row_string += "   "
                else:
                    row_string += " # "

                # node content done, now do the right side of the node.

                if "east" in node_exits:
                    if "west" in node_entrances:
                        if node_name in edge_restr:
                            if edge_restr[node_name]["direction"] == 'east':
                                kl = KL_COLORS[edge_restr[node_name]["key_level"]]
                                row_string += kl + "!" + w
                            else:
                                row_string += " "
                        else:
                            row_string += " "
                    else:
                        row_string += ">"
                else:  # There is no east exit, check if there's a west entrance.
                    if "west" in node_entrances:
                        row_string += "<"
                    else:
                        row_string += "|"

                    if c == map.data["dim_x"] - 1:
                        row_string = row_string[:-1] + B + row_string[-1:] + w

                if "south" in node_exits:
                    if "north" in node_entrances:
                        if node_name in edge_restr:
                            if edge_restr[node_name]["direction"] == 'south':
                                kl = KL_COLORS[edge_restr[node_name]["key_level"]]
                                under_string += (kl + ".__" + w + "+")
                            else:
                                under_string += "   +"
                        else:
                            under_string += "   +"
                    else:  # south is directed, 1-way.
                        under_string += " v +"

                    if c == map.data["dim_x"] - 1:
                        over_string = over_string[:-1] + B + over_string[-1:] + w
                        under_string = under_string[:-1] + B + under_string[-1:] + w
                else:  # Check if there is a northern entrance, 1-way
                    if "north" in node_entrances:
                        under_string += " ^ +"
                    else:
                        under_string += "---+"
                    # coloring
                    if c == map.data["dim_x"] - 1:
                        over_string = over_string[:-1] + B + over_string[-1:] + w
                        # under_string += "---{C+{x"
                        under_string = under_string[:-1] + B + under_string[-1:] + w

            # close color if needed.
            if r == 0:
                over_string += w

            if r == map.data["dim_y"] - 1:
                under_string += w  # Bottom row, so finally escape color.

            # complete bottom string.
            if r == row_start:
                row_string = over_string + "\n" + row_string + "\n" + under_string
            else:
                row_string = row_string + "\n" + under_string
            report_lst.append(row_string)
        return report_lst

    # CARVING

    def random_position(self, map):
        map.data["cur_row"] = random.randint(0, int(map.data["dim_y"]) - 1)
        map.data["cur_col"] = random.randint(0, int(map.data["dim_x"]) - 1)
        map.data["cur_lev"] = random.randint(0, int(map.data["dim_z"]) - 1)
        map.data["cur_q"] = random.randint(0, int(map.data["dim_q"]) - 1)

    def reset(self, map, view=True):
        """
        When passed a map, it will reset the map for digging and manipulation.
        All dug out nodes and edges will revert to uncarved.
        :param map:
        :param view:
        :return:
        """
        map.reset_graph()
        if view:
            self.view(map)

    def auto_dig(self, map):
        map.recursive_backtrack3()

    def dig(self, map, direction, view=True, **kwargs):
        """
        When passed a direction, this will set the node in that
        direction to 'carved' -- without a direction, the current node
        will be set to 'carved' if it is not already.
        :param map: map to be dug
        :param view: boolean, view the map after dig is complete?
        :param kwargs: direction=str, row=int, col=int, level=int, q=int, move=bool, directed=bool
        :return:
        """
        map.dig(direction=direction, **kwargs)
        if view:
            self.view(map)

    def move(self, map, direction, view=True):
        """
        moves in directions like "north, east", etc.
        Can be supplied with single character as well.
        :param map:
        :param direction:
        :param kwargs:
        :return:
        """
        map.move(direction)
        if view:
            self.view(map)

    def goto(self, map, row=0, column=0, level=0, q=0, view=True):
        """
        update the current position for the specified map object.
        :param map:
        :param row:
        :param column:
        :param level:
        :param q:
        :param kwargs:
        :return:
        """
        if int(row) in range(0, map.data["dim_y"]) and int(column) in range(0, map.data["dim_x"]) and int(level) in range(0, map.data["dim_z"]) and int(q) in range(0, map.data["dim_q"]):
            map.data["cur_row"] = int(row)
            map.data["cur_col"] = int(column)
            map.data["cur_lev"] = int(level)
            map.data["cur_q"] = int(q)
        else:
            raise Exception("Goto location not valid.")

        if view:
            self.view(map)


class Map(object):
    NAME = 'Map'
    SIGNATURE = '"name"="Map Name", "author"="str", "rows"="int", "columns"="int", "levels"="int", "max_carved_nodes_percent"="int"'
    COMMANDS = []

    def __init__(self, name=None, seed=None, author=None, description='A Map object.', rows=3, columns=3, levels=1, phases=1, max_carved_nodes_percent=100, autocarve=True, random_start=False, draw=False, river=50, keys=0):
        """
        Remove seed, max_carved, autocarve, randomstart, draw, river and keys from this, place in MapGenerator instead.
        """
        self.data = dict()
        self.data["id"] = self.get_random_hash()
        self.data["name"] = name
        self.data["description"] = description
        self.data["class"] = self.__class__.__name__  # For brain export/import.
        self.data["locked"] = False   # If True, cannot be edited, not implemented yet.

        if seed:
            self.data["seed"] = int(seed)
            random.seed(int(seed))

        # Defaults, overridden by kwargs possibly.
        self.data["dim_x"] = int(columns)  # columns
        self.data["dim_y"] = int(rows)  # rows
        self.data["dim_z"] = int(levels)  # levels
        self.data["dim_q"] = int(phases)  # Fourth dimension 'hither/yon' hither = u, yon = d

        # Max carved nodes.
        self.data["max_carved_nodes_percent"] = int(max_carved_nodes_percent)
        self.data["max_carved_nodes"] = int(((self.data["max_carved_nodes_percent"] / 100.00) * (self.data["dim_x"] * self.data["dim_y"] * self.data["dim_z"] * self.data["dim_q"])))

        #  Key levels progress from 0, 1, 2, etc.
        self.data["highest_key_level"] = int(keys)
        self.data["current_key_level"] = 0
        shifts = self.create_key_level_shifts(self.data["max_carved_nodes"], self.data["highest_key_level"])
        self.data["key_level_shifts"] = shifts

        # Other attributes.
        self.data["river"] = river   # Likelihood of continuing in straight line.
        self.data["z_river"] = 95    # Likelihood of remaining on the current level.
        self.data["q_river"] = 50    # Likelihood of remaining hither.

        # CurrentPosition
        if random_start:
            self.data["cur_row"] = random.randint(0, int(rows) - 1)
            self.data["cur_col"] = random.randint(0, int(columns) - 1)
            self.data["cur_lev"] = random.randint(0, int(levels) - 1)
            self.data["cur_q"] = random.randint(0, int(phases) - 1)
        else:
            self.data["cur_row"] = self.data["cur_col"] = self.data["cur_lev"] = self.data["cur_q"] = 0

        # Valid directions dictionary
        self.dirs = {"north": "south", "east": "west", "south": "north", "west": "east", "up": "down", "down": "up", "hither": "yon", "yon": "hither"}
        self.dir_weights = {"n": 2250, "e": 2250, "s": 2250, "w": 2250, "u": 250, "d": 250, "h": 250, "y": 250}
        self.comparisons = {(-1, 0, 0, 0): "north", (0, 1, 0, 0): "east", (1, 0, 0, 0): "south", (0, -1, 0, 0): "west", (0, 0, -1, 0): "up", (0, 0, 1, 0): "down", (0, 0, 0, -1): "hither", (0, 0, 0, 1): "yon"}
        self.dirs_short_to_long = {"n": "north", "e": "east", "s": "south", "w": "west", "u": "up", "d": "down", "h": "hither", "y": "yon"}

        # Create the map and graph.
        self.generate_graph()
        #nx.freeze(self.data["graph"])

        # Recursive Backtracking
        self.data["stack"] = []  # maintains list of directions needed for recursion.
        self.data["active_carving"] = False  # If set to True, stack not updated. For manual carving.
        self.data["last_random_carve"] = ""

        if autocarve:
            self.recursive_backtrack3()

        if draw:
            display = self.__repr__()
            print(display)

    def __repr__(self):
        """ This will show the basic Map object data. """
        desc = self.data["description"]
        class_type = self.data["class"]
        id = self.data["id"]
        dim_y, dim_x, dim_z, dim_q = self.get_map_dimensions()
        cur_row, cur_col, cur_lev, cur_q = self.get_current_position()
        repr_lst = ["{} with a description of: '{}'".format(class_type, desc)]
        repr_lst.append("id: '{}' with dimensions: {} rows, by {} columns and {} level(s)".format(id, dim_y, dim_x, dim_z, dim_q))
        repr_lst.append("Current Position is: row: {}, column: {}, level: {}, q_dim: {}".format(cur_row, cur_col, cur_lev, cur_q))

        display_lst = self.get_graph_display()
        if display_lst:
            repr_lst += display_lst

        node_lst = self.display_node_data(self.node_code(cur_row, cur_col, cur_lev, cur_q))
        if node_lst:
            repr_lst += node_lst

        repr_str = "\n".join(repr_lst)
        return repr_str

    def create_key_level_shifts(self, rooms, keys):
        """
        create n-1 key levels (final key level created during boss/goal room placement)
        Ex. 100 rooms to be carved.
        1 key --> no shift is needed. {0:100}
        2 keys --> a single shift is needed. {0:50, 1:100}
        3 keys --> 2 shifts are needed. {0:33, 1:66, 2:99}
        :param keys:
        :return:
        """
        dct = {}
        if keys == 0:
            dct[0] = int(rooms)
        else:
            step = rooms / keys
            for n in range(keys):
                v = step * (n + 1)
                dct[n] = v
        return dct

    def get_current_position(self):
        """
        :return: tuple in format (cur_row, cur_col, cur_lev, cur_q)
        """
        cur_row = self.data["cur_row"]
        cur_col = self.data["cur_col"]
        cur_lev = self.data["cur_lev"]
        cur_q = self.data["cur_q"]
        return cur_row, cur_col, cur_lev, cur_q

    def set_current_position(self, row, col, lev, q):
        """
        :param row:
        :param col:
        :param lev:
        :param q:
        :return:
        """

        if 0 <= int(row) < self.data["dim_y"]:
            self.data["cur_row"] = int(row)
        else:
            raise ValueError("The row value supplied '{}' is outside the valid range.".format(int(row)))

        if 0 <= int(col) < self.data["dim_x"]:
            self.data["cur_col"] = int(col)
        else:
            raise ValueError("The column value supplied '{}' is outside the valid range.".format(int(col)))

        if 0 <= int(lev) < self.data["dim_z"]:
            self.data["cur_lev"] = int(lev)
        else:
            raise ValueError("The level value supplied '{}' is outside the valid range.".format(int(lev)))

        if 0 <= int(q) < self.data["dim_q"]:
            self.data["cur_q"] = int(q)
        else:
            raise ValueError("The q value supplied '{}' is outside the valid range.".format(int(q)))

    def get_map_dimensions(self):
        """
        :return: tuple in format (dim_y, dim_x, dim_z, dim_q)
        """
        dim_x = self.data["dim_x"]
        dim_y = self.data["dim_y"]
        dim_z = self.data["dim_z"]
        dim_q = self.data["dim_q"]
        return dim_y, dim_x, dim_z, dim_q

    def get_random_uncarved_node(self):
        """
        This selects a random uncarved node name
        :return:
        """
        uncarved_nodes = list(self.get_uncarved_nodes())
        return random.choice(uncarved_nodes)

    def view_key_levels(self):
        print("\n".join(self.get_graph_display_keys()))

    def get_display_constraints(self):
        """
        MOVED TO MapGenerator *** remove after testing
        This will examine the Map object against the view radius, set to 4
        :return: row_start, row_end, col_start, col_end in tuple
        """
        view_radius = radius = self.data["view_radius"]
        diameter = (view_radius * 2) + 1
        max_row = self.data["dim_y"]
        max_col = self.data["dim_x"]

        if max_row < diameter:
            row_start, row_end = 0, max_row
        else:
            row_start, row_end = self.data["cur_row"] - radius, self.data["cur_row"] + radius + 1
            if row_start < 0:
                row_start = 0
                #print("row start set to: {}".format(row_start))

            if row_start > self.data["cur_row"] + radius:
                row_start = max_row

            if row_end < diameter:
                row_end = diameter

            if row_end > max_row:  # correct.
                row_end = max_row
                row_start = max_row - diameter

        if max_col < diameter:
            col_start, col_end = 0, max_col
        else:
            col_start, col_end = self.data["cur_col"] - radius, self.data["cur_col"] + radius + 1
            if col_start < 0:
                col_start = 0

            if col_start > self.data["cur_col"] + radius:
                col_start = max_col

            if col_end < diameter:
                col_end = diameter

            if col_end > max_col:  # correct.
                col_end = max_col
                col_start = max_col - diameter

        return row_start, row_end, col_start, col_end

    def get_graph_display_old(self):
        """
        COLOR CONDITIONS TO CHECK
        row                 column                  location                        os/rs/us = over,row,under
        0 < r < dim_y - 1   0 < c < dim_x -1        non-edge, non-corner node       pass
        ( in order in which they will be encountered )
        0                   0                       upper-left corner               os color
        0                   0 < c < dim_x - 1       top edge                        pass, color code should be in place already  ***
        0                   dim_x - 1               upper-right corner              os escape
        0 < r < dim_y - 1   0                       left edge                       rs color, rs escape
        0 < r < dim_y - 1   dim_x - 1               right edge                      rs color, rs escape
        dim_y - 1           0                       lower-left corner               us color
        dim_y - 1           0 < c < dim_x - 1       bottom edge                     pass, color code should be in place already   ***
        dim_y - 1           dim_x - 1               lower-right corner              us escape
        """

        report_lst = []  # This will hold the compiled row_strings.

        row_start, row_end, col_start, col_end = self.get_display_constraints()

        for r in xrange(row_start, row_end):
            row_string = ""  # Not defaulting to "|" because view could be truncated.

            # check color conditions for rows
            if r == 0:  # Could be upper left or upper right corner. Check in column loop.
                over_string = B + "+"
            else:
                over_string = "+"

            if r == self.data["dim_y"] - 1:  # treat as bottom left corner, when in column loop, check if bottom right.
                under_string = B + "+"
            else:
                under_string = "+"

            for c in xrange(col_start, col_end):

                # get basic node data
                node_name = self.node_code(r, c, self.data["cur_lev"], self.data["cur_q"])
                node_carved = self.data["graph"].node[node_name]["carved"]
                node_exits = self.get_carved_outward_edges_by_direction(node_name)
                node_entrances = self.get_carved_inward_edges_by_direction(node_name)
                door_data = []

                # if topmost row, then build an over_string, subsequent rows will use under_string only.
                if r == row_start:  # The first row in the display, so determine top row.
                    if "north" in node_exits:
                        if "south" in node_entrances:
                            over_string += "   +"
                        else:
                            over_string += " ^ +"
                    else:
                        if "south" in node_entrances:
                            over_string += " v +"
                        else:
                            over_string += "---+"

                # determine of we're on a left edge, and if so, handle row_string color
                if (c == 0) and (0 < r < self.data["dim_y"] - 1):
                    over_string = B + over_string[:1] + w + over_string[1:]
                    row_string += B
                    under_string = B + under_string + w
                elif (c == 0) and (r == self.data["dim_y"] - 1):
                    row_string += B
                    under_string = B + under_string
                elif (c == 0) and (r == 0):
                    row_string += B
                    under_string = B + under_string + w

                # if we're in the first display column.
                if (c == col_start) and ("west" in node_exits):
                    if "west" in door_data:
                        #print("XXX west door data is: {}".format(door_data["west"]))
                        row_string += G + "|" + w
                    else:
                        row_string += "|"

                elif (c == col_start) and ("west" not in node_exits):
                    row_string += "|"

                # escape color code, if needed.
                if c == 0:
                    row_string += w

                # Left edge of node done, now start node content.

                if r == self.data["cur_row"] and c == self.data["cur_col"]:
                    row_string += R + " O" + w + " "
                elif node_carved:  # blank node
                    if "up" in node_exits and "down" in node_exits:
                        row_string += " X "
                    elif "up" in node_exits and "down" not in node_exits:
                        row_string += " ^ "
                    elif "up" not in node_exits and "down" in node_exits:
                        row_string += " v "
                    else:
                        row_string += "   "
                else:
                    row_string += " # "

                # node content done, now do the right side of the node.

                if "east" in node_exits:
                    if "west" in node_entrances:
                        if "east" in door_data:
                            #print("XXX east door data is: {}".format(door_data["east"]))
                            row_string += G + "|" + w
                        else:
                            row_string += " "
                    else:
                        row_string += ">"
                else:  # There is no east exit, check if there's a west entrance.
                    if "west" in node_entrances:
                        row_string += "<"
                    else:
                        row_string += "|"

                    if c == self.data["dim_x"] - 1:
                        row_string = row_string[:-1] + B + row_string[-1:] + w

                if "south" in node_exits:
                    if "north" in node_entrances:
                        under_string += "   +"
                    else:  # south is directed, 1-way.
                        under_string += " v +"

                    if c == self.data["dim_x"] - 1:
                        over_string = over_string[:-1] + B + over_string[-1:] + w
                        # under_string += "   {C+{x"
                        under_string = under_string[:-1] + B + under_string[-1:] + w
                else:  # Check if there is a northern entrance, 1-way
                    if "north" in node_entrances:
                        under_string += " ^ +"
                    else:
                        under_string += "---+"
                    # coloring
                    if c == self.data["dim_x"] - 1:
                        over_string = over_string[:-1] + B + over_string[-1:] + w
                        # under_string += "---{C+{x"
                        under_string = under_string[:-1] + B + under_string[-1:] + w

            # close color if needed.
            if r == 0:
                over_string += w

            if r == self.data["dim_y"] - 1:
                under_string += w  # Bottom row, so finally escape color.

            # complete bottom string.
            if r == row_start:
                row_string = over_string + "\n" + row_string + "\n" + under_string
            else:
                row_string = row_string + "\n" + under_string
            report_lst.append(row_string)
        return report_lst

    def get_graph_display(self, key_levels=False):
        """
        MOVED TO MapGenerator *** remove after testing
        1/9/2018 -- added edge condition checking.
        COLOR CONDITIONS TO CHECK
        row                 column                  location                        os/rs/us = over,row,under
        0 < r < dim_y - 1   0 < c < dim_x -1        non-edge, non-corner node       pass
        ( in order in which they will be encountered )
        0                   0                       upper-left corner               os color
        0                   0 < c < dim_x - 1       top edge                        pass, color code should be in place already  ***
        0                   dim_x - 1               upper-right corner              os escape
        0 < r < dim_y - 1   0                       left edge                       rs color, rs escape
        0 < r < dim_y - 1   dim_x - 1               right edge                      rs color, rs escape
        dim_y - 1           0                       lower-left corner               us color
        dim_y - 1           0 < c < dim_x - 1       bottom edge                     pass, color code should be in place already   ***
        dim_y - 1           dim_x - 1               lower-right corner              us escape
        """

        report_lst = []  # This will hold the compiled row_strings.
        edges = self.get_edge_data()  # This gets all edge data for the entire graph.
        # edge_restr is a dict of dicts of all edges that have an edge restriction (key_level) and a direction
        # of east, south, or down -- which is all the function requires to draw the map.
        edge_restr = {_[0]: {"direction": _[2]["direction"], "key_level": _[2]["key_level"]} for _ in edges if _[2]["key_level"] is not None and ((_[2]["direction"] == 'east') or (_[2]["direction"] == 'south') or (_[2]["direction"] == 'down'))}
        door_data = []

        row_start, row_end, col_start, col_end = self.get_display_constraints()

        for r in xrange(row_start, row_end):
            row_string = ""  # Not defaulting to "|" because view could be truncated.

            # check color conditions for rows
            if r == 0:  # Could be upper left or upper right corner. Check in column loop.
                over_string = B + "+"
            else:
                over_string = "+"

            if r == self.data["dim_y"] - 1:  # treat as bottom left corner, when in column loop, check if bottom right.
                under_string = B + "+"
            else:
                under_string = "+"

            for c in xrange(col_start, col_end):

                # get basic node data
                node_name = self.node_code(r, c, self.data["cur_lev"], self.data["cur_q"])
                node_carved = self.data["graph"].node[node_name]["carved"]
                node_exits = self.get_carved_outward_edges_by_direction(node_name)
                node_entrances = self.get_carved_inward_edges_by_direction(node_name)

                # if topmost row, then build an over_string, subsequent rows will use under_string only.
                if r == row_start:  # The first row in the display, so determine top row.
                    if "north" in node_exits:
                        if "south" in node_entrances:
                            over_string += "   +"
                        else:
                            over_string += " ^ +"
                    else:
                        if "south" in node_entrances:
                            over_string += " v +"
                        else:
                            over_string += "---+"

                # determine of we're on a left edge, and if so, handle row_string color
                if (c == 0) and (0 < r < self.data["dim_y"] - 1):
                    over_string = B + over_string[:1] + w + over_string[1:]
                    row_string += B
                    under_string = B + under_string + w
                elif (c == 0) and (r == self.data["dim_y"] - 1):
                    row_string += B
                    under_string = B + under_string
                elif (c == 0) and (r == 0):
                    row_string += B
                    under_string = B + under_string + w

                # if we're in the first display column.
                if (c == col_start) and ("west" in node_exits):
                    if "west" in door_data:
                        #print("XXX west door data is: {}".format(door_data["west"]))
                        row_string += G + "|" + w
                    else:
                        row_string += "|"

                elif (c == col_start) and ("west" not in node_exits):
                    row_string += "|"

                # escape color code, if needed.
                if c == 0:
                    row_string += w

                # Left edge of node done, now start node content.

                if r == self.data["cur_row"] and c == self.data["cur_col"]:
                    row_string += R + " O" + w + " "
                elif node_carved:  # blank node
                    if key_levels:  # show key_level for carved cells.
                        key_level = self.get_node_key_level(node_name)
                        klc = KL_COLORS.get(key_level, w)
                        if 10 > key_level >= 0:
                            row_string += " {}{}{} ".format(klc, int(key_level), w)
                        else:
                            row_string += " % "
                    else:
                        if "up" in node_exits and "down" in node_exits:
                            row_string += " X "
                        elif "up" in node_exits and "down" not in node_exits:
                            row_string += " ^ "
                        elif "up" not in node_exits and "down" in node_exits:
                            row_string += " v "
                        else:
                            row_string += "   "
                else:
                    row_string += " # "

                # node content done, now do the right side of the node.

                if "east" in node_exits:
                    if "west" in node_entrances:
                        if node_name in edge_restr:
                            if edge_restr[node_name]["direction"] == 'east':
                                kl = KL_COLORS[edge_restr[node_name]["key_level"]]
                                row_string += kl + "!" + w
                            else:
                                row_string += " "
                        else:
                            row_string += " "
                    else:
                        row_string += ">"
                else:  # There is no east exit, check if there's a west entrance.
                    if "west" in node_entrances:
                        row_string += "<"
                    else:
                        row_string += "|"

                    if c == self.data["dim_x"] - 1:
                        row_string = row_string[:-1] + B + row_string[-1:] + w

                if "south" in node_exits:
                    if "north" in node_entrances:
                        if node_name in edge_restr:
                            if edge_restr[node_name]["direction"] == 'south':
                                kl = KL_COLORS[edge_restr[node_name]["key_level"]]
                                under_string += (kl + ".__" + w + "+")
                            else:
                                under_string += "   +"
                        else:
                            under_string += "   +"
                    else:  # south is directed, 1-way.
                        under_string += " v +"

                    if c == self.data["dim_x"] - 1:
                        over_string = over_string[:-1] + B + over_string[-1:] + w
                        # under_string += "   {C+{x"
                        under_string = under_string[:-1] + B + under_string[-1:] + w
                else:  # Check if there is a northern entrance, 1-way
                    if "north" in node_entrances:
                        under_string += " ^ +"
                    else:
                        under_string += "---+"
                    # coloring
                    if c == self.data["dim_x"] - 1:
                        over_string = over_string[:-1] + B + over_string[-1:] + w
                        # under_string += "---{C+{x"
                        under_string = under_string[:-1] + B + under_string[-1:] + w

            # close color if needed.
            if r == 0:
                over_string += w

            if r == self.data["dim_y"] - 1:
                under_string += w  # Bottom row, so finally escape color.

            # complete bottom string.
            if r == row_start:
                row_string = over_string + "\n" + row_string + "\n" + under_string
            else:
                row_string = row_string + "\n" + under_string
            report_lst.append(row_string)
        return report_lst

    def get_graph_display_keys(self):
        """
        Just as get_graph_display, but indicates key_level in center of node.
        """

        report_lst = []  # This will hold the compiled row_strings.

        row_start, row_end, col_start, col_end = self.get_display_constraints()

        for r in xrange(row_start, row_end):
            row_string = ""  # Not defaulting to "|" because view could be truncated.

            # check color conditions for rows
            if r == 0:  # Could be upper left or upper right corner. Check in column loop.
                over_string = B + "+"
            else:
                over_string = "+"

            if r == self.data["dim_y"] - 1:  # treat as bottom left corner, when in column loop, check if bottom right.
                under_string = B + "+"
            else:
                under_string = "+"

            for c in xrange(col_start, col_end):

                # get basic node data
                node_name = self.node_code(r, c, self.data["cur_lev"], self.data["cur_q"])
                node_carved = self.data["graph"].node[node_name]["carved"]
                node_exits = self.get_carved_outward_edges_by_direction(node_name)
                node_entrances = self.get_carved_inward_edges_by_direction(node_name)
                door_data = []

                # if topmost row, then build an over_string, subsequent rows will use under_string only.
                if r == row_start:  # The first row in the display, so determine top row.
                    if "north" in node_exits:
                        if "south" in node_entrances:
                            over_string += "   +"
                        else:
                            over_string += " ^ +"
                    else:
                        if "south" in node_entrances:
                            over_string += " v +"
                        else:
                            over_string += "---+"

                # determine of we're on a left edge, and if so, handle row_string color
                if (c == 0) and (0 < r < self.data["dim_y"] - 1):
                    over_string = B + over_string[:1] + w + over_string[1:]
                    row_string += B
                    under_string = B + under_string + w
                elif (c == 0) and (r == self.data["dim_y"] - 1):
                    row_string += B
                    under_string = B + under_string
                elif (c == 0) and (r == 0):
                    row_string += B
                    under_string = B + under_string + w

                # if we're in the first display column.
                if (c == col_start) and ("west" in node_exits):
                    if "west" in door_data:
                        #print("XXX west door data is: {}".format(door_data["west"]))
                        row_string += G + "|" + w
                    else:
                        row_string += "|"

                elif (c == col_start) and ("west" not in node_exits):
                    row_string += "|"

                # escape color code, if needed.
                if c == 0:
                    row_string += w

                # Left edge of node done, now start node content.

                if r == self.data["cur_row"] and c == self.data["cur_col"]:
                    row_string += R + " O" + w + " "
                elif node_carved:  # blank node
                    key_level = self.get_node_key_level(node_name)
                    klc = KL_COLORS.get(key_level, w)
                    if 10 > key_level >= 0:
                        row_string += " {}{}{} ".format(klc, int(key_level), w)
                    else:
                        row_string += " % "
                else:
                    row_string += " # "

                # node content done, now do the right side of the node.

                if "east" in node_exits:
                    if "west" in node_entrances:
                        if "east" in door_data:
                            #print("XXX east door data is: {}".format(door_data["east"]))
                            row_string += G + "|" + w
                        else:
                            row_string += " "
                    else:
                        row_string += ">"
                else:  # There is no east exit, check if there's a west entrance.
                    if "west" in node_entrances:
                        row_string += "<"
                    else:
                        row_string += "|"

                    if c == self.data["dim_x"] - 1:
                        row_string = row_string[:-1] + B + row_string[-1:] + w

                if "south" in node_exits:
                    if "north" in node_entrances:
                        under_string += "   +"
                    else:  # south is directed, 1-way.
                        under_string += " v +"

                    if c == self.data["dim_x"] - 1:
                        over_string = over_string[:-1] + B + over_string[-1:] + w
                        # under_string += "   {C+{x"
                        under_string = under_string[:-1] + B + under_string[-1:] + w
                else:  # Check if there is a northern entrance, 1-way
                    if "north" in node_entrances:
                        under_string += " ^ +"
                    else:
                        under_string += "---+"
                    # coloring
                    if c == self.data["dim_x"] - 1:
                        over_string = over_string[:-1] + B + over_string[-1:] + w
                        # under_string += "---{C+{x"
                        under_string = under_string[:-1] + B + under_string[-1:] + w

            # close color if needed.
            if r == 0:
                over_string += w

            if r == self.data["dim_y"] - 1:
                under_string += w  # Bottom row, so finally escape color.

            # complete bottom string.
            if r == row_start:
                row_string = over_string + "\n" + row_string + "\n" + under_string
            else:
                row_string = row_string + "\n" + under_string
            report_lst.append(row_string)
        return report_lst

    def get_random_hash(self):
        """Get a randomized hash. Provided by Guillaume VanderEst."""
        return "%010x" % random.getrandbits(10 * 4)

    def set_name(self, name=""):
        if name:
            self.data["name"] = name
        else:
            pass

    # NetworkX Graph object generation.

    def generate_graph(self):
        # This method uses networkx DiGraph class, so that directed edges are supported.
        # First create an empty DiGraph object.
        self.data["graph"] = nx.DiGraph()

        # Create the node/edges structure familiar to Cartesian coordinate-based spaces.
        self.create_default_node_structure()

        # Now set all the node attributes to their default values.
        self.set_all_nodes_to_uncarved()
        self.set_all_nodes_to_zero_intensity()
        self.set_all_node_mob_resets_to_empty()
        self.set_all_node_object_resets_to_empty()
        self.clear_all_vnums_from_nodes()
        self.clear_all_masking_from_nodes()

    def create_default_node_structure(self):
        """
        This creates the 'Cartesian' node and edge structure.
        If the nodes don't already exist, they are added. If the edges don't exist, they are created.
        If the edges already exist, then their attributes are reset to their default 'uncarved' condition.
        This function does nothing to node attributes.
        :return:
        """
        paths = self.get_cardinal_edges(self.data["dim_x"], self.data["dim_y"], self.data["dim_z"], self.data["dim_q"])
        # Now add all the edges to the DiGraph. This also adds the nodes as well, although without attributes.
        for key in paths:
            lst = paths[key]
            for path in lst:
                self.data["graph"].add_path(path, carved=False, direction=key, desc="", name="", key_level=None, flags=[])

    def set_all_nodes_to_uncarved(self):
        """
        Every node in the graph will have its "carved" attribute set to False,
        and their "exits" lists will be cleared.
        :return:
        """
        for n in self.data["graph"].nodes():
            self.data["graph"].node[n]["carved"] = False
            self.data["graph"].node[n]["exits"] = []  # This may not be necessary.
            self.data["graph"].node[n]["key_level"] = None

    def set_all_nodes_to_zero_intensity(self):
        """
        Every node in the graph will have its "carved" attribute set to False,
        and their "exits" lists will be cleared.
        :return:
        """
        for n in self.data["graph"].nodes():
            self.data["graph"].node[n]["intensity"] = 0

    def set_all_node_mob_resets_to_empty(self):
        """
        Every node in the graph will have its "mobs" attribute list set to []
        :return:
        """
        for n in self.data["graph"].nodes():
            self.data["graph"].node[n]["mobs"] = []

    def set_all_node_object_resets_to_empty(self):
        """
        Every node in the graph will have its "mobs" attribute list set to []
        :return:
        """
        for n in self.data["graph"].nodes():
            self.data["graph"].node[n]["objects"] = []

    def clear_all_vnums_from_nodes(self):
        """
        Every node in the graph will have its "vnum" attribute emptied.
        :return:
        """
        for n in self.data["graph"].nodes():
            self.data["graph"].node[n]["vnum"] = ""

    def clear_all_masking_from_nodes(self):
        """
        Every node in the graph will have its "masked" attribute set to False.
        :return:
        """
        for n in self.data["graph"].nodes():
            self.data["graph"].node[n]["masked"] = False

    def reset_graph(self, keep_masking=True, autocarve=False, redraw=False):
        """
        This will uncarve the entire graph and clear the stack.
        Basically, this will wipe the slate clean of all carving-related changes.
        But it will retain all other settings.
        :return:
        """
        self.create_default_node_structure()
        self.set_all_nodes_to_uncarved()
        self.set_all_nodes_to_zero_intensity()
        self.set_all_node_mob_resets_to_empty()
        self.set_all_node_object_resets_to_empty()
        self.clear_all_vnums_from_nodes()
        self.data["current_key_level"] = 0
        if not keep_masking:
            self.clear_all_masking_from_nodes()
        self.clear_stack()
        if autocarve:
            self.recursive_backtrack3()
        if redraw:
            display = self.__repr__()
            print(display)

    def get_cardinal_edges(self, x_dim, y_dim, z_dim, q_dim):
        """
        return a list of lists, each interior list representing a path of edges.
        :param x_dim:
        :param y_dim:
        :param z_dim:
        :param q_dim:
        :return:
        """
        all_paths = dict()
        # These functions return a dictionary, which then gets added to all_paths
        all_paths.update(self.get_row_paths(y_dim, x_dim, z_dim, q_dim))
        all_paths.update(self.get_column_paths(y_dim, x_dim, z_dim, q_dim))
        all_paths.update(self.get_level_paths(y_dim, x_dim, z_dim, q_dim))
        all_paths.update(self.get_dim_paths(y_dim, x_dim, z_dim, q_dim))
        return all_paths

    # Loop through all dimensions. (enters T.A.R.D.I.S)

    def get_column_paths(self, rows, columns, levels, dims):

        paths = dict()  # This will hold all the generated paths.
        paths["south"] = []
        paths["north"] = []

        for q in xrange(dims):
            for z in xrange(levels):
                for y in xrange(columns):
                    column_path = []
                    for x in xrange(rows):
                        column_path.append(self.node_code(x, y, z, q))
                    if len(column_path) > 1:  # if there's only a single node, it's not a path.
                        paths["south"].append(tuple(column_path))
                        column_path.reverse()  # Reverse the path, since this is DiGraph.
                        paths["north"].append(tuple(column_path))
        return paths

    def get_row_paths(self, rows, columns, levels, dims):

        paths = dict()  # This will hold all the generated path dictionaries. Convert to lists later.
        paths["east"] = []
        paths["west"] = []

        for q in xrange(dims):
            for z in xrange(levels):
                for x in xrange(rows):
                    row_path = []
                    for y in xrange(columns):
                        row_path.append(self.node_code(x, y, z, q))
                    if len(row_path) > 1:  # if there's only a single node, it's not a path.
                        paths["east"].append(tuple(row_path))
                        row_path.reverse()
                        paths["west"].append(tuple(row_path))
        return paths

    def get_level_paths(self, rows, columns, levels, dims):

        paths = dict()  # This will hold all the generated path dictionaries. Convert to lists later.
        paths["down"] = []
        paths["up"] = []

        for q in xrange(dims):
            for x in xrange(rows):
                for y in xrange(columns):
                    levels_path = []
                    for z in xrange(levels):
                        levels_path.append(self.node_code(x, y, z, q))
                    if len(levels_path) > 1:  # if there's only a single node, it's not a path.
                        paths["down"].append(tuple(levels_path))
                        levels_path.reverse()
                        paths["up"].append(tuple(levels_path))
        return paths

    def get_dim_paths(self, rows, columns, levels, dims):

        paths = dict()  # This will hold all the generated path dictionaries. Convert to lists later.
        paths["yon"] = []
        paths["hither"] = []

        for x in xrange(rows):
            for y in xrange(columns):
                for z in xrange(levels):
                    dims_path = []
                    for q in xrange(dims):
                        dims_path.append(self.node_code(x, y, z, q))
                    if len(dims_path) > 1:  # if there's only a single node, it's not a path.
                        paths["yon"].append(tuple(dims_path))
                        dims_path.reverse()
                        paths["hither"].append(tuple(dims_path))
        return paths

    # End the NetworkX Graph generation/maintenance methods.

    # Getters and Setters

    def get_edge_data(self, node_name=None):
        """
        This returns raw edge data in the form:
        ('0:4:0:0', '0:5:0:0', {'direction': 'east', 'flags': [], 'name': '', 'desc': '', 'key_level': None, 'carved': True})
        :param node_name: optional -- can specify node or use a list of nodes. If none specified, all edges returned.
        :return: returns edge data, will require narrowing down most likely.
        """
        if node_name:
            return self.data["graph"].edges(node_name, data=True)
        else:
            return self.data["graph"].edges(data=True)

    def get_node_data(self, node_name):
        return self.data["graph"].node[node_name]

    def get_node_key_level(self, node_name):
        return self.data["graph"].node[node_name].get("key_level", None)

    def display_node_data(self, node_name):
        """
        NOT USED YET.
        :param node_name:
        :return:
        """
        data = self.get_node_data(node_name)
        ret_lst = []

        if data:

            exits = ", ".join(data["exits"])
            if exits:
                ret_lst.append("Exits: {}".format(exits))

            objects = ", ".join(data["objects"])
            if objects:
                ret_lst.append("Objs: {}".format(objects))

            mobs = ", ".join(data["mobs"])
            if mobs:
                ret_lst.append("Mobs: {}".format(mobs))

            vnum = data["vnum"]
            if vnum:
                ret_lst.append("VNUM: {}".format(vnum))

            carved = data["carved"]
            masked = data["masked"]
            ret_lst.append("Carved: {} | Masked: {}".format(carved, masked))

        return ret_lst

    def get_uncarved_nodes(self):
        """
        Returns a set of nodes that are uncarved.
        :return:
        """
        return set(n for n, d in self.data["graph"].nodes(data=True) if d['carved'] is False)

    def get_carved_nodes(self):
        """
        Returns a set of nodes that are carved.
        :return:
        """
        return set(n for n, d in self.data["graph"].nodes(data=True) if d['carved'] is True)

    def get_carved_inward_edges(self, node_name):
        """
        Returns a list of 'in-bound' edges (leading from) the node_name that are carved.
        Example: get_in_edges_by_direction("0:0:0:0") might yield [(0:1:0:0), (0:0:0:0), {}]
        Most likely used display functions to check if edges are directed (1-way) or not.
        :param node_name:
        :return:
        """
        g = self.data["graph"]
        in_edges = g.in_edges(node_name, data=True)
        carved_in_edges = []
        for tup in in_edges:
            data = tup[2]
            if data["carved"] is True:
                carved_in_edges.append(tup)  # "north", "south", etc.
        return carved_in_edges

    def get_carved_inward_edges_by_direction(self, node_name):
        """
        Returns a list of 'in-bound' edges (leading to) the node_name that are carved.
        Example: get_in_edges_by_direction("0:0:0:0") might yield ["n", "u", "w"]
        Most likely used display functions to check if edges are directed (1-way) or not.
        :param node_name:
        :return:
        """
        carved_inward_edges = self.get_carved_inward_edges(node_name)
        return [x[2]["direction"] for x in carved_inward_edges]

    def get_carved_outward_edges(self, node_name):
        """
        Returns a list of 'out-bound' edges (leading from) the node_name that are carved.
        each entry in list is a tuple in this format:
        ('6:2:0:0', '7:2:0:0', {'direction': 'south', 'flags': [], 'name': '', 'desc': '', 'key_level': 3, 'carved': True})
        Most likely used display functions to check if edges are directed (1-way) or not.
        :param node_name:
        :return:
        """
        g = self.data["graph"]
        out_edges = g.out_edges(node_name, data=True)
        carved_out_edges = []
        for tup in out_edges:
            data = tup[2]
            if data["carved"] is True:
                carved_out_edges.append(tup)  # "north", "south", etc.
        return carved_out_edges

    def get_carved_outward_edges_by_direction(self, node_name):
        """
        Returns a list of 'outward' edges (leading from) the node_name that are carved.
        :param node_name:
        :return:
        """
        carved_outward_edges = self.get_carved_outward_edges(node_name)  # the raw edge data
        return [x[2]["direction"] for x in carved_outward_edges]

    def that_direction_is_carved(self, node_name, dir):
        is_carved = False
        val_dir = self.valid_direction(dir)
        if val_dir:
            if val_dir in self.data["graph"].node[node_name]["exits"]:
                is_carved = True
        return is_carved

    def get_uncarved_node_directions(self, node_name):
        """
        This will return a list of uncarved cardinal directions that lead to uncarved nodes,
        when passed a node_name.
        To be used by carving functions.
        :param node_name: in the format "1:0:0:1" row:col:level:q
        :return: list of allowed directions from the named node ["e", "n"]
        """

        uncarved_out_dirs = []
        nbunch = [node_name]

        out_dirs = self.data["graph"].out_edges(nbunch, data=True)  # Returns outbound edges.
        for edge in out_dirs:
            if edge[2]["carved"] is False and self.data["graph"].node[edge[1]]["carved"] is False:
                uncarved_out_dirs.append(edge[2]["direction"])
        return uncarved_out_dirs

    def get_valid_directions(self, node_name):
        """
        This will return valid cardinal directions. For example, if the node_name is on the easternmost edge,
        then 'e' will not be on the list of returned directions. This is border or edge detection.
        :param node_name: (0, 1, 0, ,0)
        :return: ["north", "east"]
        """
        out_dirs = []
        edges = self.data["graph"].out_edges(node_name, data=True)
        if edges:
            for entry in edges:
                out_dirs.append(entry[2]["direction"])
        return out_dirs

    def that_direction_is_possible(self, node_name, dir):
        if dir in self.get_valid_directions(node_name):
            return True
        else:
            return False

    def uncarve_edge(self, node1, node2):
        self.data["graph"].adj[node1][node2]["carved"] = False
        self.clear_edge_key_level(node1, node2)

    def carve_edge(self, node1, node2, key_level=None):
        """

        :param node1:
        :param node2:
        :param key_level: The integer value that should be set.
        :return:
        """
        self.data["graph"].adj[node1][node2]["carved"] = True
        if key_level:
            self.set_edge_key_level(node1, node2, key_level)
        else:
            pass

    def clear_edge_key_level(self, node1, node2):
        self.data["graph"].adj[node1][node2]["key_level"] = None

    def set_edge_key_level(self, node1, node2, key_level):
        """
        This amounts to a locked or 'keyed' door/edge.
        :param node1: starting
        :param node2:
        :param key_level:
        :return:
        """
        self.data["graph"].adj[node1][node2]["key_level"] = int(key_level)
        print(B + "Edge {} --> {} set to key_level {}".format(node1, node2, key_level) + w)

    def carve_node(self, node_name):
        self.data["graph"].node[node_name]["carved"] = True
        # If the key_level for this node has NOT been previously set, set it now.
        if not self.get_node_key_level(node_name):
            self.set_node_key_level(node_name)
        else:
            print(R + "!!! node: {} already has key_level: '{}' set, do not reset!".format(node_name, self.get_node_key_level(node_name)) + w)

    def uncarve_node(self, node_name):
        self.data["graph"].node[node_name]["carved"] = False

    def set_node_key_level(self, node_name, key_level=None):
        if key_level:
            self.data["graph"].node[node_name]["key_level"] = int(key_level)
        else:
            self.data["graph"].node[node_name]["key_level"] = self.data["current_key_level"]

    # Cell commands.

    def node_check(self, direction, row=None, col=None, lev=None, q=None):
        """
        This checks to see if the direction from the specified node would take us
        beyond the map border. May need refinement when passthrough code is implemented.
        Defaults to using the current position.
        """
        if (row is None) and (col is None) and (lev is None) and (q is None):
            row, col, lev, q = self.data["cur_row"], self.data["cur_col"], self.data["cur_lev"], self.data["cur_q"]

        if direction == "north" and row > 0:
            return True
        elif direction == "east" and col < self.data["dim_x"] - 1:
            return True
        elif direction == "south" and row < self.data["dim_y"] - 1:
            return True
        elif direction == "west" and col > 0:
            return True
        elif direction == "up" and lev > 0:
            return True
        elif direction == "down" and lev < self.data["dim_z"] - 1:
            return True
        elif direction == "hither" and q > 0:
            return True
        elif direction == "yon" and q < self.data["dim_q"] - 1:
            return True
        else:
            return False

    # Cell movement.

    def valid_direction(self, direction):
        """
        This will return None if the direction is not valid.
        If a single character is passed "n", then "north" is returned.
        :param direction:
        :return:
        """
        if direction:
            direction = direction.lower()
            if direction in self.dirs.keys():
                return direction
            elif len(direction) == 1 and direction in self.dirs_short_to_long.keys():
                return self.dirs_short_to_long[direction]
            else:
                return None
        else:
            return None

    def move(self, dir):
        """
        This version of node move doesn't just increment/decrement the cur_pos values
        in accordance to the dimensions of the Map object. Instead, it finds the
        current node_name and then find all the 'out' edges and check their "direction"
        attribute to see if they match the input direction. If it does, then the name
        of the destination node (#:#:#:#) is decoded into its components and passed
        to the relevant position attributes. This is better for 'wraparound' border
        nodes, which wouldn't be addressed by the older method.
        :param dir: the direction we want to move
        :return:
        """
        node_name = self.node_code()
        val_dir = self.valid_direction(dir)
        if val_dir:
            g = self.data["graph"]
            out_edges = g.out_edges(node_name, data=True)
            for tup in out_edges:
                data = tup[2]
                if data["direction"] == val_dir:
                    destination_node = tup[1]
                    self.data["cur_row"], self.data["cur_col"], self.data["cur_lev"], self.data["cur_q"] = self.node_uncode(destination_node)

    def node_is_carved(self, row=None, col=None, lev=None, q=None):
        if (row is None) and (col is None) and (lev is None) and (q is None):
            row, col, lev, q = self.data["cur_row"], self.data["cur_col"], self.data["cur_lev"], self.data["cur_q"]

        node_name = self.node_code(row, col, lev, q)

        if self.data["graph"].node[node_name]["carved"]:
            return True
        else:
            return False

    def node_open(self, direction, row=None, col=None, lev=None, q=None):
        """
        'opening' a node in specified direction does more than just carve that particular edge,
        it also updates the 'exits' attribute for the specified cell.
        :param direction:
        :param row:
        :param col:
        :param lev:
        :param q:
        :return:
        """

        if (row is None) and (col is None) and (lev is None) and (q is None):
            row, col, lev, q = self.data["cur_row"], self.data["cur_col"], self.data["cur_lev"], self.data["cur_q"]

        node_name = self.node_code(row, col, lev, q)
        val_dir = self.valid_direction(direction)

        if val_dir:
            g = self.data["graph"]

            if val_dir not in g.node[node_name]["exits"]:  # This may be removed, as its possible to get carved exits.
                self.add_node_exit(node_name, val_dir)

            # Now update the edge carved attribute.

            # Now check if the key_level should increment.
            print("node_open: should_key_level_increment = {}".format(self.should_key_level_increment()))
            if self.should_key_level_increment():
                self.increment_key_level()
                key_level_has_incremented = True
                print(G + "node_open: key_level_has_incremented = {}".format(key_level_has_incremented) + w)
            else:
                key_level_has_incremented = False
                #print(R + "node_open: key_level_has_incremented = {}".format(key_level_has_incremented) + w)

            if val_dir == "north":
                if key_level_has_incremented or (self.get_node_key_level(node_name) < self.data["current_key_level"]):
                    self.carve_edge(node_name, self.node_code(row - 1, col, lev, q), key_level=self.data["current_key_level"])
                else:
                    self.carve_edge(node_name, self.node_code(row - 1, col, lev, q))

            elif val_dir == "south":
                if key_level_has_incremented or (self.get_node_key_level(node_name) < self.data["current_key_level"]):
                    self.carve_edge(node_name, self.node_code(row + 1, col, lev, q), key_level=self.data["current_key_level"])
                else:
                    self.carve_edge(node_name, self.node_code(row + 1, col, lev, q))

            elif val_dir == "east":
                if key_level_has_incremented or (self.get_node_key_level(node_name) < self.data["current_key_level"]):
                    self.carve_edge(node_name, self.node_code(row, col + 1, lev, q), key_level=self.data["current_key_level"])
                else:
                    self.carve_edge(node_name, self.node_code(row, col + 1, lev, q))

            elif val_dir == "west":
                if key_level_has_incremented or (self.get_node_key_level(node_name) < self.data["current_key_level"]):
                    self.carve_edge(node_name, self.node_code(row, col - 1, lev, q), key_level=self.data["current_key_level"])
                else:
                    self.carve_edge(node_name, self.node_code(row, col - 1, lev, q))

            elif val_dir == "up":
                if key_level_has_incremented or (self.get_node_key_level(node_name) < self.data["current_key_level"]):
                    self.carve_edge(node_name, self.node_code(row, col, lev - 1, q), key_level=self.data["current_key_level"])
                else:
                    self.carve_edge(node_name, self.node_code(row, col, lev - 1, q))

            elif val_dir == "down":
                if key_level_has_incremented or (self.get_node_key_level(node_name) < self.data["current_key_level"]):
                    self.carve_edge(node_name, self.node_code(row, col, lev + 1, q), key_level=self.data["current_key_level"])
                else:
                    self.carve_edge(node_name, self.node_code(row, col, lev + 1, q))

            elif val_dir == "hither":
                if key_level_has_incremented or (self.get_node_key_level(node_name) < self.data["current_key_level"]):
                    self.carve_edge(node_name, self.node_code(row, col, lev, q - 1), key_level=self.data["current_key_level"])
                else:
                    self.carve_edge(node_name, self.node_code(row, col, lev, q - 1))

            elif val_dir == "yon":
                if key_level_has_incremented or (self.get_node_key_level(node_name) < self.data["current_key_level"]):
                    self.carve_edge(node_name, self.node_code(row, col, lev, q + 1), key_level=self.data["current_key_level"])
                else:
                    self.carve_edge(node_name, self.node_code(row, col, lev, q + 1))

            else:
                pass
        else:
            #print("node_open error: unknown direction input")
            pass

    # node_close removes a direction from a node's "exits" dictionary
    def node_close(self, direction, row=None, col=None, lev=None, q=None):

        if row is None and col is None and lev is None and q is None:
            row, col, lev, q = self.data["cur_row"], self.data["cur_col"], self.data["cur_lev"], self.data["cur_q"]

        node_name = self.node_code(row, col, lev, q)

        val_dir = self.valid_direction(direction)

        if val_dir:

            self.remove_node_exit(node_name, val_dir)

            # now update the edge carved attribute
            if val_dir == "north":
                self.uncarve_edge(node_name, self.node_code(row - 1, col, lev, q))
                self.remove_node_exit(node_name, "north")

            elif val_dir == "south":
                self.uncarve_edge(node_name, self.node_code(row + 1, col, lev, q))
                self.remove_node_exit(node_name, "south")

            elif val_dir == "east":
                self.uncarve_edge(node_name, self.node_code(row, col + 1, lev, q))
                self.remove_node_exit(node_name, "east")

            elif val_dir == "west":
                self.uncarve_edge(node_name, self.node_code(row, col - 1, lev, q))
                self.remove_node_exit(node_name, "west")

            elif val_dir == "up":
                self.uncarve_edge(node_name, self.node_code(row, col, lev - 1, q))
                self.remove_node_exit(node_name, "up")

            elif val_dir == "down":
                self.uncarve_edge(node_name, self.node_code(row, col, lev + 1, q))
                self.remove_node_exit(node_name, "down")

            elif val_dir == "hither":
                self.uncarve_edge(node_name, self.node_code(row, col, lev, q - 1))
                self.remove_node_exit(node_name, "hither")

            elif val_dir == "yon":
                self.uncarve_edge(node_name, self.node_code(row, col, lev, q + 1))
                self.remove_node_exit(node_name, "yon")
        else:
            #print("node_close error: unknown direction input")
            pass

    def remove_node_exit(self, node_name, direction):
        """
        This removes the exit entry "north", "south", etc. from a node's "exits" attribute list.
        :param node_name:
        :param dir:
        :return:
        """
        #print("removing {} to exits at node: {}".format(direction, node_name))
        exits = self.data["graph"].node[node_name]["exits"]
        if direction in exits:
            exits.remove(direction)
        else:
            #print("remove_node_exit: direction '{}' NOT found in 'exits' - not removed.")
            pass

    def add_node_exit(self, node_name, direction):
        """
        This adds the exit entry "n", "s", etc. to a node's "exits" attribute list.
        :param node_name:
        :param dir:
        :return:
        """
        exits = self.data["graph"].node[node_name]["exits"]
        if direction not in exits:
            #print("adding {} to exits at node: {}".format(direction, node_name))
            exits.append(direction)
        else:
            pass
            #print("add_node_exit: direction '{}' found in 'exits' - not added.")

    # node_code -- returns the 'x:y:z:q' string for a given node. For membership checks. Default to cur_pos.
    def node_code(self, row=None, col=None, lev=None, q=None):
        if row is None and col is None and lev is None and q is None:
            row = self.data["cur_row"]
            col = self.data["cur_col"]
            lev = self.data["cur_lev"]
            q = self.data["cur_q"]
        return str(row) + ":" + str(col) + ":" + str(lev) + ":" + str(q)

    def node_uncode(self, node_name):
        """
        When given a node_name this will return a tuple.
        :param node_name: "1:1:0:0"
        :return: (1, 1, 0, 0)
        """
        data = node_name.split(":")
        int_data = map(int, data)
        return tuple(int_data)

    # Carving methods.

    def dig(self, direction=None, row=None, column=None, level=None, q=None, move=True, directed=False):

        if row is None and column is None and level is None and q is None:
            row, column, level, q = self.data["cur_row"], self.data["cur_col"], self.data["cur_lev"], self.data["cur_q"]
        node_name = self.node_code(row, column, level, q)

        # Set the current node/node as carved, if it has not been.
        if not self.node_is_carved():
            self.carve_node(node_name)

        if self.should_key_level_increment():
            self.increment_key_level()
            key_level_has_incremented = True
            print(G + "node_open: key_level_has_incremented = {}".format(key_level_has_incremented) + w)
        else:
            key_level_has_incremented = False

        if direction is not None:

            checked_dir = self.valid_direction(direction)

            if checked_dir:
                if checked_dir in self.get_valid_directions(node_name):  # Border detection.

                    out_edges = self.get_edge_data(node_name)
                    dest_node = [x[1] for x in out_edges if x[2]["direction"] == checked_dir][0]

                    if key_level_has_incremented:
                        self.carve_edge(node_name, dest_node, key_level=self.data["current_key_level"])
                        # Perform reverse edge as well.
                        self.carve_edge(dest_node, node_name, key_level=self.data["current_key_level"])
                    else:
                        # check to see if the key_level of the current node is lower than the current_key_level.
                        # If it IS, then set the key_level for the edge to whatever it currently is.
                        # Else, do not set edge.
                        if self.get_node_key_level(node_name) < self.data["current_key_level"]:
                            print("!!! The current node {} has a kl of {}, which is lower than then current key_level, which is {}".format(node_name, self.get_node_key_level(node_name), self.data["current_key_level"]))
                            print("!!! carving from node {} to node {} and setting key_level to edge of {}".format(node_name, dest_node, self.data["current_key_level"]))
                            self.carve_edge(node_name, dest_node, key_level=self.data["current_key_level"])
                            self.carve_edge(dest_node, node_name, key_level=self.data["current_key_level"])
                        else:
                            self.carve_edge(node_name, dest_node)

                    self.carve_node(dest_node)

                    if not directed:  # a 'directed' edge is one-way only.
                        if key_level_has_incremented:  # set key_level for edge to be previous key_level.
                            self.carve_edge(dest_node, node_name, key_level=self.data["current_key_level"])
                            self.carve_edge(node_name, dest_node, key_level=self.data["current_key_level"])
                        else:
                            self.carve_edge(dest_node, node_name)  # This opens the node in the opposite direction!

                    if move:  # Move after we've carved in direction we wanted.
                        self.move(checked_dir)

                    #self.node_open(checked_dir)
                    #self.move(checked_dir)
                    #self.dig()  # no direction given, so carves the destination node position, where we are now

                    if not self.data["active_carving"]:
                        self.stack_add(checked_dir)
                else:
                    #print("Edge of map.")
                    pass
            else:
                #print("Direction '{}' not a valid direction.".format(direction))
                pass
        else:  # No direction value was passed, so do nothing besides carve current node.
            #print("node_carve: No direction was passed.")
            pass

    def node_uncarve(self, row=None, col=None, lev=None, q=None):
        # is never supplied with direction, since uncarving a node polls
        # the connected nodes and closes off their edges to the node.
        # If not used on a deadend node, this can lead to isolated nodes.
        if row is None and col is None and lev is None and q is None:
            row, col, lev, q = self.data["cur_row"], self.data["cur_col"], self.data["cur_lev"], self.data["cur_q"]

        node_name = self.node_code(row, col, lev, q)

        if self.data["graph"].node[node_name]["carved"] is True:
            # mark the current node as uncarved.
            self.data["graph"].node[node_name]["carved"] = False
            # now go through all the connected nodes.
            exits = copy.deepcopy(self.data["graph"].node[node_name]["exits"])
            #print("exits found during uncarve are: {}".format(exits))
            #print("# of exits are: {}".format(len(exits)))
            if exits:
                for x in exits:
                    if x in self.dirs:
                        #print("{} found in self.dirs!".format(x))
                        self.node_close(x)
                        self.move(x)
                        self.node_close(self.dirs[x])
                        self.move(self.dirs[x])
                    else:
                        #print("Direction '{}' not a valid direction.")
                        pass

            else:
                #print("There are no exits to close.")
                pass
        else:
            #print("The node at ({}, {}, {}, {}) isn't carved, so it cannot be uncarved.".format(row, col, lev, q))
            pass

    # Recursive Backtracking Algorithm

    def remove_random_deadend(self):
        pass

    def weight_dir(self, direction, weight):
        if direction.lower() in self.dir_weights:
            direction = direction.lower()
            if type(weight) == int:
                self.dir_weights[direction] = weight
                #print(self.dir_weights)
                total = sum(self.dir_weights.values())
                #print("total = {}".format(total))
                for key, value in self.dir_weights.items():
                    pass
                    #print("{}: {} of {} = {:.2f} % chance".format(key, value, total, (value / float(total)) * 100))

    def weight_dir2(self, dir_list, percentage):
        total_added = 0
        dir_weight = (float(percentage) / 100) * 10000
        #print("set each item in {} to {}".format(dir_list, dir_weight))

    def recursive_backtrack(self):
        while len(self.carved_nodes) < self.max_carved_nodes:
            self.dig_random_direction4()

    def recursive_backtrack2(self):
        while (len(self.get_carved_nodes()) < self.data["max_carved_nodes"]) or (len(self.data["stack"]) == 0):
            self.dig_random_direction4()

    def recursive_backtrack3(self):
        while (len(self.get_carved_nodes()) < self.data["max_carved_nodes"]) or (len(self.data["stack"]) == 0):
            #print("total carved nodes: {} | max_carved_nodes: {} | stack_length: {}".format(len(self.get_carved_nodes()), self.data["max_carved_nodes"], len(self.data["stack"])))
            self.dig_random_direction()

    def recursive_backtrack4(self):
        while (len(self.get_carved_nodes()) < self.data["max_carved_nodes"]) or (len(self.data["stack"]) == 0):
            #print("total carved nodes: {} | max_carved_nodes: {} | stack_length: {}".format(len(self.get_carved_nodes()), self.data["max_carved_nodes"], len(self.data["stack"])))
            self.dig_random_direction()

    def increment_key_level(self):
        self.data["current_key_level"] += 1


    def should_key_level_increment(self):
        if self.data["current_key_level"] < (self.data["highest_key_level"] - 1):
            if len(self.get_carved_nodes()) == self.data["key_level_shifts"][self.data["current_key_level"]]:
                return True
            else:
                return False
        else:
            return False

    def stack_add(self, direction):
        if direction.lower() in self.dirs.keys():
            self.data["stack"].append(self.dirs[direction])

    def clear_stack(self):
        self.data["stack"] = []

    def adjacent_node_comparison(self, tup):
        node_code = self.node_code()
        comparison = ()
        for i in range(len(tup)):
            comparison += (tup[i] - node_code[i],)
            # print("comparison at {} is {}".format(i, comparison))
            # result is in form: "n", "s", etc.
        result = self.comparisons[comparison]
        #print("result is '{}'".format(result))
        return result

    def possible_directions_prob_calc(self, dir_list):
        prob_dict = {}  # form: {"calc_range": int, "n":(1, 26), ...}
        if len(dir_list) > 1:  # There's more than one choice.
            # calculate probability chances
            start_total = 1
            prob_dict["calc_range"] = 1
            for dir in dir_list:
                new_tup = (start_total, start_total + self.dir_weights[dir])
                prob_dict[dir] = new_tup
                start_total += self.dir_weights[dir]
                prob_dict["calc_range"] += self.dir_weights[dir]
            return prob_dict
        else:  # There's only one choice.
            prob_dict = {"calc_range": 101, dir_list[0]: (1, 101)}
            return prob_dict

    def dig_random_direction(self):
        possible_directions = self.get_uncarved_node_directions(self.node_code())
        #print("pos_directions are: {}".format(possible_directions))
        if possible_directions:
            random_direction = random.choice(possible_directions)
            #print("dig_random_direction: random direction is '{}'".format(random_direction))
            self.dig(random_direction)
            self.data["last_random_carve"] = random_direction
        else:
            #print("dig_random_direction: no directions available, recurse() called")
            self.recurse()

    def dig_random_direction2(self):
        # make use of river attribute.
        open_nodes = list(self.get_uncarved_neighbors())
        if open_nodes:
            possible_directions = []
            for node in open_nodes:
                possible_directions.append(self.adjacent_node_comparison(node))
            if (self.data["last_random_carve"] in possible_directions) and (random.randrange(1, 100) < self.river):
                # use last direction
                self.dig(self.data["last_random_carve"])
            else:  # random direction.
                random_node = random.choice(open_nodes)
                # print("random_node is '{}'".format(random_node))
                random_direction = random.choice(possible_directions)
                # print("random_direction is '{}'".format(random_direction))
                self.dig(random_direction)
                self.data["last_random_carve"] = random_direction
        else:
            #print("No uncarved neighbors found. RECURSION required.")
            self.recurse()

    def dig_random_direction3(self):
        # make use of river attribute AND z_river, to control up/down
        possible_directions = self.get_uncarved_node_directions(self.node_code())
        #print("pos_directions are: {}".format(possible_directions))
        if possible_directions:
            if (self.data["last_random_carve"] in possible_directions) and (random.randrange(1, 100) < self.data["river"]):
                # use last direction
                self.dig(self.data["last_random_carve"])
            else:  # random direction.
                if ((len(possible_directions) == 2) and (("up" and "down") in possible_directions)) or ((("up" in possible_directions) or ("down" in possible_directions)) and len(possible_directions) == 1):
                    # No choice but to go up or down.
                    random_direction = random.choice(possible_directions)
                    self.dig(random_direction)
                    self.data["last_random_carve"] = random_direction
                else:  # we have some options aside from up or down.
                    if random.randrange(1, 100) >= self.data["z_river"]:
                        #print("z_river not met.")
                        if "up" in possible_directions:
                            possible_directions.remove("up")
                        if "down" in possible_directions:
                            possible_directions.remove("down")
                    random_direction = random.choice(possible_directions)
                    self.dig(random_direction)
                    self.data["last_random_carve"] = random_direction
        else:
            self.recurse()

    def dig_random_direction3_1(self):
        # make use of river attribute AND z_river, to control up/down
        possible_directions = self.get_uncarved_node_directions(self.node_code())
        #print("pos_directions are: {}".format(possible_directions))
        if possible_directions:
            if (self.data["last_random_carve"] in possible_directions) and (random.randrange(1, 100) < self.data["river"]):
                # use last direction
                self.dig(self.data["last_random_carve"])
            else:  # random direction.
                if ((len(possible_directions) == 2) and (("up" and "down") in possible_directions)) or ((("up" in possible_directions) or ("down" in possible_directions)) and len(possible_directions) == 1):
                    # No choice but to go up or down.
                    random_direction = random.choice(possible_directions)
                    self.dig(random_direction)
                    self.data["last_random_carve"] = random_direction
                else:  # we have some options aside from up or down.
                    if random.randrange(1, 100) >= self.data["z_river"]:
                        #print("z_river not met.")
                        if "up" in possible_directions:
                            possible_directions.remove("up")
                        if "down" in possible_directions:
                            possible_directions.remove("down")
                    random_direction = random.choice(possible_directions)
                    self.dig(random_direction)
                    self.data["last_random_carve"] = random_direction
        else:
            self.recurse()

    def dig_random_direction4(self):
        # make use of river attribute AND dir_weights to weight direction choice.
        open_nodes = list(self.get_uncarved_neighbors())
        if open_nodes:
            possible_directions = []
            for node in open_nodes:
                possible_directions.append(self.adjacent_node_comparison(node))
            if (self.data["last_random_carve"] in possible_directions) and (random.randrange(1, 100) < self.data["river"]):
                # use last direction
                self.dig(self.data["last_random_carve"])
            else:  # random direction using weighted probabilities.
                weighted_directions = self.possible_directions_prob_calc(possible_directions)
                rand_number = random.randrange(1, weighted_directions["calc_range"])
                for direction in weighted_directions:
                    if direction in self.dirs:
                        #print("dir from weighted_directions is: {}".format(direction))
                        if weighted_directions[direction][0] <= rand_number < weighted_directions[direction][1]:
                            self.dig(direction)
                            self.data["last_random_carve"] = direction
                            break
        else:
            self.recurse()

    def recurse(self):
        if self.data["stack"]:
            recurse_direction = self.data["stack"].pop()
            #print("Recursing in the direction '{}'".format(recurse_direction))
            self.move(recurse_direction)
        else:
            #print("ERROR! Stack is empty.")
            pass